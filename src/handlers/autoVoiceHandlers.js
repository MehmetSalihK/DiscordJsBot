import { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, StringSelectMenuBuilder, ModalBuilder, TextInputBuilder, TextInputStyle, PermissionFlagsBits, MessageFlags } from 'discord.js';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const autoVoiceChannelsPath = path.join(__dirname, '../../json/autoVoiceChannels.json');
const voiceActivityLogsPath = path.join(__dirname, '../../json/voiceActivityLogs.json');

// Fonction pour charger les donn√©es
function loadAutoVoiceData() {
    try {
        if (!fs.existsSync(autoVoiceChannelsPath)) {
            fs.writeFileSync(autoVoiceChannelsPath, '{}');
            return {};
        }
        const data = fs.readFileSync(autoVoiceChannelsPath, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        console.error('[AUTO-VOICE] Erreur lors du chargement des donn√©es:', error);
        return {};
    }
}

// Fonction pour sauvegarder les donn√©es
function saveAutoVoiceData(data) {
    try {
        fs.writeFileSync(autoVoiceChannelsPath, JSON.stringify(data, null, 2));
    } catch (error) {
        console.error('[AUTO-VOICE] Erreur lors de la sauvegarde des donn√©es:', error);
    }
}

// Fonction pour charger les logs d'activit√© vocale
function loadVoiceActivityLogs() {
    try {
        if (!fs.existsSync(voiceActivityLogsPath)) {
            fs.writeFileSync(voiceActivityLogsPath, '{}');
            return {};
        }
        const data = fs.readFileSync(voiceActivityLogsPath, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        console.error('[VOICE-LOGS] Erreur lors du chargement des logs:', error);
        return [];{};
    }
}

// Gestionnaire principal pour les boutons du panneau de gestion
async function handleManagementButtons(interaction) {
    try {
        const [prefix, action, channelId] = interaction.customId.split('_');
        const channel = interaction.guild.channels.cache.get(channelId);
        
        if (!channel) {
            const errorEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå Salon introuvable')
                .setDescription('Le salon vocal n\'existe plus ou a √©t√© supprim√©.')
                .setTimestamp();
            
            return await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
        }

        const autoVoiceData = loadAutoVoiceData();
        const guildId = interaction.guild.id;
        
        // Trouver le propri√©taire du salon
        let channelData = null;
        if (autoVoiceData[guildId] && autoVoiceData[guildId].userChannels) {
            channelData = Object.values(autoVoiceData[guildId].userChannels).find(
                data => data.channelId === channelId
            );
        }

        if (!channelData) {
            const errorEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå **Donn√©es du salon introuvables**')
                .setDescription(`
> üîç **Probl√®me d√©tect√©**
> Ce salon n'est pas g√©r√© par le syst√®me de salons vocaux automatiques.

\`\`\`yaml
Salon: ${channel.name}
Type: Non g√©r√© par le syst√®me
Action: Impossible √† ex√©cuter
\`\`\`

**üí° Solution :** Utilisez uniquement ce panneau sur les salons cr√©√©s automatiquement.
                `)
                .setTimestamp();
            
            return await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
        }

        // V√©rifier si l'utilisateur est le propri√©taire ou a les permissions
        const isOwner = channelData.ownerId === interaction.user.id;
        const isAuthorized = channelData.authorizedUsers && channelData.authorizedUsers.includes(interaction.user.id);
        
        if (!isOwner && !isAuthorized) {
            const errorEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('üö´ **Acc√®s Refus√©**')
                .setDescription(`
> üîê **Permissions insuffisantes**
> Seul le **propri√©taire** du salon ou les utilisateurs **autoris√©s** peuvent utiliser ces contr√¥les.

\`\`\`yaml
Salon: ${channel.name}
Votre statut: Non autoris√©
Action requise: Permission du propri√©taire
\`\`\`
                `)
                .addFields([
                    { name: 'üëë **Propri√©taire du salon**', value: `<@${channelData.ownerId}>`, inline: true },
                    { name: 'üîí **Votre statut**', value: '`‚ùå Non autoris√©`', inline: true },
                    { name: 'üí° **Solution**', value: 'Demandez au propri√©taire de vous donner des permissions', inline: false }
                ])
                .setTimestamp();
            
            return await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
        }

        // console.log(`[AUTO-VOICE] ${interaction.user.displayName} utilise l'action: ${action} sur le salon: ${channel.name}`);

        switch (action) {
            case 'kick':
                await handleKickAction(interaction, channel, channelData);
                break;
            case 'ban':
                await handleBanAction(interaction, channel, channelData);
                break;
            case 'unban':
                await handleUnbanAction(interaction, channel, channelData);
                break;
            case 'blacklist':
                await handleBlacklistAction(interaction, channel, channelData);
                break;
            case 'permissions':
                await handlePermissionsAction(interaction, channel, channelData);
                break;
            case 'edit':
                await handleEditAction(interaction, channel, channelData);
                break;
            case 'privacy':
                await handlePrivacyAction(interaction, channel, channelData);
                break;
            case 'refresh':
                await handleRefreshAction(interaction, channel, channelData);
                break;
            case 'delete':
                await handleDeleteAction(interaction, channel, channelData);
                break;
            case 'logs':
                await handleLogsAction(interaction, channel, channelData);
                break;
            case 'logs_realtime':
                await handleLogsAction(interaction, channel, channelData);
                break;
            default:
                const unknownEmbed = new EmbedBuilder()
                    .setColor('#FF0000')
                    .setTitle('‚ùå Action inconnue')
                    .setDescription('Cette action n\'est pas reconnue par le syst√®me.')
                    .setTimestamp();
                await interaction.reply({ embeds: [unknownEmbed], flags: MessageFlags.Ephemeral });
        }

    } catch (error) {
        console.error('[AUTO-VOICE] Erreur dans le gestionnaire de boutons:', error);
        
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ùå System Error')
            .setDescription('An error occurred while processing your request.')
            .setTimestamp();
        
        if (interaction.replied || interaction.deferred) {
            await interaction.followUp({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
        } else {
            await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
        }
    }
}

// ü¶µ Action: Kick member
async function handleKickAction(interaction, channel, channelData) {
    const members = channel.members.filter(member => member.id !== channelData.ownerId);
    
    if (members.size === 0) {
        const noMembersEmbed = new EmbedBuilder()
            .setColor('#FFA500')
            .setTitle('‚ö†Ô∏è Aucun membre √† expulser')
            .setDescription('Il n\'y a aucun membre dans ce salon √† part vous.')
            .addFields([
                { name: 'üí° Astuce', value: 'Les membres appara√Ætront ici d√®s qu\'ils rejoindront votre salon.', inline: false }
            ])
            .setTimestamp();
        
        return await interaction.reply({ embeds: [noMembersEmbed], flags: MessageFlags.Ephemeral });
    }

    const selectMenu = new StringSelectMenuBuilder()
        .setCustomId(`autovoice_kick_select_${channel.id}`)
        .setPlaceholder('ü¶µ S√©lectionnez un membre √† expulser')
        .addOptions(
            members.map(member => ({
                label: member.displayName,
                value: member.id,
                description: `${member.user.tag}`,
                emoji: 'ü¶µ'
            }))
        );

    const row = new ActionRowBuilder().addComponents(selectMenu);

    const kickEmbed = new EmbedBuilder()
        .setColor('#FF6B6B')
        .setTitle('ü¶µ Expulser un membre')
        .setDescription('S√©lectionnez le membre que vous souhaitez expulser de votre salon vocal.')
        .addFields([
            { name: 'üë• Membres pr√©sents', value: `${members.size} membre(s)`, inline: true },
            { name: '‚ö†Ô∏è Note', value: 'Le membre pourra rejoindre √† nouveau sauf s\'il est banni.', inline: false }
        ])
        .setTimestamp();

    await interaction.reply({
        embeds: [kickEmbed],
        components: [row],
        flags: MessageFlags.Ephemeral
    });
}

// üî® Action: Ban member
async function handleBanAction(interaction, channel, channelData) {
    const members = channel.members.filter(member => member.id !== channelData.ownerId);
    
    if (members.size === 0) {
        const noMembersEmbed = new EmbedBuilder()
            .setColor('#FFA500')
            .setTitle('‚ö†Ô∏è Aucun membre √† bannir')
            .setDescription('Il n\'y a aucun membre dans ce salon √† part vous.')
            .addFields([
                { name: 'üí° Astuce', value: 'Les membres appara√Ætront ici d√®s qu\'ils rejoindront votre salon.', inline: false }
            ])
            .setTimestamp();
        
        return await interaction.reply({ embeds: [noMembersEmbed], flags: MessageFlags.Ephemeral });
    }

    const selectMenu = new StringSelectMenuBuilder()
        .setCustomId(`autovoice_ban_select_${channel.id}`)
        .setPlaceholder('üî® S√©lectionnez un membre √† bannir')
        .addOptions(
            members.map(member => ({
                label: member.displayName,
                value: member.id,
                description: `${member.user.tag}`,
                emoji: 'üî®'
            }))
        );

    const row = new ActionRowBuilder().addComponents(selectMenu);

    const banEmbed = new EmbedBuilder()
        .setColor('#DC143C')
        .setTitle('üî® Bannir un membre')
        .setDescription('S√©lectionnez le membre que vous souhaitez bannir d√©finitivement de votre salon vocal.')
        .addFields([
            { name: 'üë• Membres pr√©sents', value: `${members.size} membre(s)`, inline: true },
            { name: 'üö´ Effet', value: 'Le membre ne pourra plus rejoindre ce salon.', inline: false }
        ])
        .setTimestamp();

    await interaction.reply({
        embeds: [banEmbed],
        components: [row],
        flags: MessageFlags.Ephemeral
    });
}

// üü¢ Action: Unban member
async function handleUnbanAction(interaction, channel, channelData) {
    const autoVoiceData = loadAutoVoiceData();
    const guildId = interaction.guild.id;
    
    if (!channelData.blacklistedUsers || channelData.blacklistedUsers.length === 0) {
        const noBannedEmbed = new EmbedBuilder()
            .setColor('#FFA500')
            .setTitle('‚ö†Ô∏è Aucun membre banni')
            .setDescription('Il n\'y a aucun membre banni dans ce salon.')
            .addFields([
                { name: 'üí° Information', value: 'Les membres bannis appara√Ætront ici pour pouvoir les d√©bannir.', inline: false }
            ])
            .setTimestamp();
        
        return await interaction.reply({ embeds: [noBannedEmbed], flags: MessageFlags.Ephemeral });
    }

    const selectOptions = [];
    for (const userId of channelData.blacklistedUsers) {
        try {
            const user = await interaction.client.users.fetch(userId);
            selectOptions.push({
                label: user.displayName || user.username,
                value: userId,
                description: `${user.tag}`,
                emoji: 'üü¢'
            });
        } catch (error) {
            console.error(`[AUTO-VOICE] Impossible de r√©cup√©rer l'utilisateur ${userId}:`, error);
        }
    }

    if (selectOptions.length === 0) {
        const noValidUsersEmbed = new EmbedBuilder()
            .setColor('#FFA500')
            .setTitle('‚ö†Ô∏è Aucun utilisateur valide trouv√©')
            .setDescription('Impossible de r√©cup√©rer les informations des utilisateurs bannis.')
            .addFields([
                { name: 'üîß Solution', value: 'V√©rifiez que les utilisateurs bannis existent toujours.', inline: false }
            ])
            .setTimestamp();
        
        return await interaction.reply({ embeds: [noValidUsersEmbed], flags: MessageFlags.Ephemeral });
    }

    const selectMenu = new StringSelectMenuBuilder()
        .setCustomId(`autovoice_unban_select_${channel.id}`)
        .setPlaceholder('üü¢ S√©lectionnez un utilisateur √† d√©bannir')
        .addOptions(selectOptions);

    const row = new ActionRowBuilder().addComponents(selectMenu);

    const unbanEmbed = new EmbedBuilder()
        .setColor('#32CD32')
        .setTitle('üü¢ D√©bannir un membre')
        .setDescription('S√©lectionnez l\'utilisateur que vous souhaitez d√©bannir de votre salon vocal.')
        .addFields([
            { name: 'üö´ Membres bannis', value: `${selectOptions.length} utilisateur(s)`, inline: true },
            { name: '‚úÖ Effet', value: 'L\'utilisateur pourra √† nouveau rejoindre ce salon.', inline: false }
        ])
        .setTimestamp();

    await interaction.reply({
        embeds: [unbanEmbed],
        components: [row],
        flags: MessageFlags.Ephemeral
    });
}

// üö´ Action: Blacklist user
async function handleBlacklistAction(interaction, channel, channelData) {
    const modal = new ModalBuilder()
        .setCustomId(`autovoice_blacklist_modal_${channel.id}`)
        .setTitle('üö´ Bannir un utilisateur');

    const userInput = new TextInputBuilder()
        .setCustomId('blacklist_user')
        .setLabel('ID utilisateur ou mention')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder('123456789012345678 ou @utilisateur')
        .setRequired(true);

    const row = new ActionRowBuilder().addComponents(userInput);
    modal.addComponents(row);

    await interaction.showModal(modal);
}

// üîë Action: Grant permissions
async function handlePermissionsAction(interaction, channel, channelData) {
    const modal = new ModalBuilder()
        .setCustomId(`autovoice_permissions_modal_${channel.id}`)
        .setTitle('üîë Accorder des permissions');

    const userInput = new TextInputBuilder()
        .setCustomId('permission_user')
        .setLabel('ID utilisateur ou mention')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder('123456789012345678 ou @utilisateur')
        .setRequired(true);

    const row = new ActionRowBuilder().addComponents(userInput);
    modal.addComponents(row);

    await interaction.showModal(modal);
}

// ‚úèÔ∏è Action: Edit channel
async function handleEditAction(interaction, channel, channelData) {
    const modal = new ModalBuilder()
        .setCustomId(`autovoice_edit_modal_${channel.id}`)
        .setTitle('‚úèÔ∏è Modifier le salon');

    const nameInput = new TextInputBuilder()
        .setCustomId('channel_name')
        .setLabel('Nouveau nom du salon')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder(channel.name)
        .setRequired(false);

    const limitInput = new TextInputBuilder()
        .setCustomId('user_limit')
        .setLabel('Limite d\'utilisateurs (0 = illimit√©)')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder(channel.userLimit.toString())
        .setRequired(false);

    const bitrateInput = new TextInputBuilder()
        .setCustomId('bitrate')
        .setLabel('D√©bit audio (en kbps, max 384)')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder((channel.bitrate / 1000).toString())
        .setRequired(false);

    const firstRow = new ActionRowBuilder().addComponents(nameInput);
    const secondRow = new ActionRowBuilder().addComponents(limitInput);
    const thirdRow = new ActionRowBuilder().addComponents(bitrateInput);

    modal.addComponents(firstRow, secondRow, thirdRow);

    await interaction.showModal(modal);
}

// Gestionnaire pour les s√©lections de menus
async function handleSelectMenuInteraction(interaction) {
    try {
        const [prefix, action, type, channelId] = interaction.customId.split('_');
        const channel = interaction.guild.channels.cache.get(channelId);
        
        if (!channel) {
            const errorEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå Salon introuvable')
                .setDescription('Le salon vocal n\'existe plus ou a √©t√© supprim√©.')
                .setTimestamp();
            
            return await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
        }

        const autoVoiceData = loadAutoVoiceData();
        const guildId = interaction.guild.id;
        const selectedUserId = interaction.values[0];

        // Trouver les donn√©es du salon
        const channelData = Object.values(autoVoiceData[guildId].userChannels).find(
            data => data.channelId === channelId
        );

        if (!channelData) {
            const errorEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå Donn√©es du salon introuvables')
                .setDescription('Ce salon n\'est pas g√©r√© par le syst√®me de salons vocaux automatiques.')
                .setTimestamp();
            
            return await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
        }

        switch (action) {
            case 'kick':
                await handleKickSelect(interaction, channel, channelData, selectedUserId);
                break;
            case 'ban':
                await handleBanSelect(interaction, channel, channelData, selectedUserId);
                break;
            case 'unban':
                await handleUnbanSelect(interaction, channel, channelData, selectedUserId);
                break;
        }

    } catch (error) {
        console.error('[AUTO-VOICE] Erreur dans le gestionnaire de s√©lection:', error);
        
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ùå Erreur syst√®me')
            .setDescription('Une erreur s\'est produite lors du traitement de votre s√©lection.')
            .addFields([
                { name: 'üîß Solution', value: 'Veuillez r√©essayer dans quelques instants.', inline: false }
            ])
            .setTimestamp();
        
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
    }
}

// Gestionnaire pour les s√©lections de kick
async function handleKickSelect(interaction, channel, channelData, selectedUserId) {
    try {
        const member = await interaction.guild.members.fetch(selectedUserId);
        
        if (member.voice.channel && member.voice.channel.id === channel.id) {
            await member.voice.disconnect('Expuls√© par le propri√©taire du salon');
            
            const embed = new EmbedBuilder()
                .setColor('#FFA500')
                .setTitle('ü¶µ Membre expuls√©')
                .setDescription(`‚úÖ **${member.displayName}** a √©t√© expuls√© du salon vocal.`)
                .addFields([
                    { name: 'üë§ Utilisateur expuls√©', value: `${member.user.tag} (${member.user.id})`, inline: true },
                    { name: 'üéµ Salon', value: `<#${channel.id}>`, inline: true },
                    { name: '‚ö†Ô∏è Note', value: 'L\'utilisateur peut rejoindre √† nouveau sauf s\'il est banni.', inline: false }
                ])
                .setTimestamp();
                
            await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
            // console.log(`[AUTO-VOICE] ü¶µ ${member.user.tag} expuls√© de ${channel.name} par ${interaction.user.tag}`);
        } else {
            const errorEmbed = new EmbedBuilder()
                .setColor('#FFA500')
                .setTitle('‚ö†Ô∏è Utilisateur non pr√©sent')
                .setDescription('Cet utilisateur n\'est pas dans le salon vocal.')
                .addFields([
                    { name: 'üí° Information', value: 'L\'utilisateur a peut-√™tre quitt√© le salon entre temps.', inline: false }
                ])
                .setTimestamp();
            
            await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
        }
    } catch (error) {
        console.error('[AUTO-VOICE] Erreur lors du kick:', error);
        
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ùå Erreur lors de l\'expulsion')
            .setDescription('Impossible d\'expulser cet utilisateur.')
            .addFields([
                { name: 'üîß Causes possibles', value: '‚Ä¢ Permissions insuffisantes\n‚Ä¢ Utilisateur introuvable\n‚Ä¢ Erreur de connexion', inline: false }
            ])
            .setTimestamp();
        
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
    }
}

// Gestionnaire pour les s√©lections de ban
async function handleBanSelect(interaction, channel, channelData, selectedUserId) {
    try {
        const member = await interaction.guild.members.fetch(selectedUserId);
        const autoVoiceData = loadAutoVoiceData();
        const guildId = interaction.guild.id;
        
        // Ajouter √† la liste noire
        if (!channelData.blacklistedUsers) {
            channelData.blacklistedUsers = [];
        }
        
        if (!channelData.blacklistedUsers.includes(selectedUserId)) {
            channelData.blacklistedUsers.push(selectedUserId);
            
            // Sauvegarder les donn√©es
            const userChannelKey = Object.keys(autoVoiceData[guildId].userChannels).find(
                key => autoVoiceData[guildId].userChannels[key].channelId === channel.id
            );
            if (userChannelKey) {
                autoVoiceData[guildId].userChannels[userChannelKey] = channelData;
                saveAutoVoiceData(autoVoiceData);
            }
        }
        
        // Expulser l'utilisateur s'il est dans le salon
        if (member.voice.channel && member.voice.channel.id === channel.id) {
            await member.voice.disconnect('Banni par le propri√©taire du salon');
        }
        
        // Retirer les permissions
        await channel.permissionOverwrites.edit(selectedUserId, {
            Connect: false,
            ViewChannel: false
        });
        
        const embed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('üî® Membre banni')
            .setDescription(`‚úÖ **${member.displayName}** a √©t√© banni d√©finitivement du salon vocal.`)
            .addFields([
                { name: 'üë§ Utilisateur banni', value: `${member.user.tag} (${member.user.id})`, inline: true },
                { name: 'üéµ Salon', value: `<#${channel.id}>`, inline: true },
                { name: 'üö´ Effet', value: 'L\'utilisateur ne peut plus rejoindre ce salon.', inline: false }
            ])
            .setTimestamp();
            
        await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
        // console.log(`[AUTO-VOICE] üî® ${member.user.tag} banni de ${channel.name} par ${interaction.user.tag}`);
        
    } catch (error) {
        console.error('[AUTO-VOICE] Erreur lors du ban:', error);
        
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ùå Erreur lors du bannissement')
            .setDescription('Impossible de bannir cet utilisateur.')
            .addFields([
                { name: 'üîß Causes possibles', value: '‚Ä¢ Permissions insuffisantes\n‚Ä¢ Utilisateur introuvable\n‚Ä¢ Erreur de sauvegarde', inline: false }
            ])
            .setTimestamp();
        
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
    }
}

// Gestionnaire pour les s√©lections d'unban
async function handleUnbanSelect(interaction, channel, channelData, selectedUserId) {
    try {
        const user = await interaction.client.users.fetch(selectedUserId);
        const autoVoiceData = loadAutoVoiceData();
        const guildId = interaction.guild.id;
        
        // Retirer de la liste noire
        if (channelData.blacklistedUsers) {
            channelData.blacklistedUsers = channelData.blacklistedUsers.filter(id => id !== selectedUserId);
            
            // Sauvegarder les donn√©es
            const userChannelKey = Object.keys(autoVoiceData[guildId].userChannels).find(
                key => autoVoiceData[guildId].userChannels[key].channelId === channel.id
            );
            if (userChannelKey) {
                autoVoiceData[guildId].userChannels[userChannelKey] = channelData;
                saveAutoVoiceData(autoVoiceData);
            }
        }
        
        // Restaurer les permissions
        await channel.permissionOverwrites.edit(selectedUserId, {
            Connect: true,
            ViewChannel: true
        });
        
        const embed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('üü¢ Membre d√©banni')
            .setDescription(`‚úÖ **${user.displayName || user.username}** a √©t√© d√©banni du salon vocal.`)
            .addFields([
                { name: 'üë§ Utilisateur d√©banni', value: `${user.tag} (${user.id})`, inline: true },
                { name: 'üéµ Salon', value: `<#${channel.id}>`, inline: true },
                { name: '‚úÖ Effet', value: 'L\'utilisateur peut √† nouveau rejoindre ce salon.', inline: false }
            ])
            .setTimestamp();
            
        await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
        // console.log(`[AUTO-VOICE] üü¢ ${user.tag} d√©banni de ${channel.name} par ${interaction.user.tag}`);
        
    } catch (error) {
        console.error('[AUTO-VOICE] Erreur lors de l\'unban:', error);
        
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ùå Erreur lors du d√©bannissement')
            .setDescription('Impossible de d√©bannir cet utilisateur.')
            .addFields([
                { name: 'üîß Causes possibles', value: '‚Ä¢ Permissions insuffisantes\n‚Ä¢ Utilisateur introuvable\n‚Ä¢ Erreur de sauvegarde', inline: false }
            ])
            .setTimestamp();
        
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
    }
}

// Gestionnaire pour les modals
async function handleModalSubmit(interaction) {
    try {
        const [prefix, action, type, channelId] = interaction.customId.split('_');
        const channel = interaction.guild.channels.cache.get(channelId);
        
        if (!channel) {
            const errorEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå Salon introuvable')
                .setDescription('Le salon vocal n\'existe plus ou a √©t√© supprim√©.')
                .setTimestamp();
            
            return await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
        }

        const autoVoiceData = loadAutoVoiceData();
        const guildId = interaction.guild.id;

        // Trouver les donn√©es du salon
        const channelData = Object.values(autoVoiceData[guildId].userChannels).find(
            data => data.channelId === channelId
        );

        if (!channelData) {
            const errorEmbed = new EmbedBuilder()
                .setColor('#FF0000')
                .setTitle('‚ùå Donn√©es du salon introuvables')
                .setDescription('Ce salon n\'est pas g√©r√© par le syst√®me de salons vocaux automatiques.')
                .setTimestamp();
            
            return await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
        }

        switch (action) {
            case 'blacklist':
                await handleBlacklistModal(interaction, channel, channelData);
                break;
            case 'permissions':
                await handlePermissionsModal(interaction, channel, channelData);
                break;
            case 'edit':
                await handleEditModal(interaction, channel, channelData);
                break;
        }

    } catch (error) {
        console.error('[AUTO-VOICE] Erreur dans le gestionnaire de modal:', error);
        
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ùå Erreur syst√®me')
            .setDescription('Une erreur s\'est produite lors du traitement de votre demande.')
            .addFields([
                { name: 'üîß Solution', value: 'Veuillez r√©essayer dans quelques instants.', inline: false }
            ])
            .setTimestamp();
        
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
    }
}

// Gestionnaire pour le modal de blacklist
async function handleBlacklistModal(interaction, channel, channelData) {
    const userInput = interaction.fields.getTextInputValue('blacklist_user');
    let userId = userInput.replace(/[<@!>]/g, '');
    
    try {
        const user = await interaction.client.users.fetch(userId);
        const autoVoiceData = loadAutoVoiceData();
        const guildId = interaction.guild.id;
        
        // Ajouter √† la liste noire
        if (!channelData.blacklistedUsers) {
            channelData.blacklistedUsers = [];
        }
        
        if (!channelData.blacklistedUsers.includes(userId)) {
            channelData.blacklistedUsers.push(userId);
            
            // Sauvegarder les donn√©es
            const userChannelKey = Object.keys(autoVoiceData[guildId].userChannels).find(
                key => autoVoiceData[guildId].userChannels[key].channelId === channel.id
            );
            if (userChannelKey) {
                autoVoiceData[guildId].userChannels[userChannelKey] = channelData;
                saveAutoVoiceData(autoVoiceData);
            }
        }
        
        // Expulser l'utilisateur s'il est dans le salon
        const member = interaction.guild.members.cache.get(userId);
        if (member && member.voice.channel && member.voice.channel.id === channel.id) {
            await member.voice.disconnect('Mis sur liste noire par le propri√©taire du salon');
        }
        
        // Retirer les permissions
        await channel.permissionOverwrites.edit(userId, {
            Connect: false,
            ViewChannel: false
        });
        
        const embed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('üö´ Utilisateur mis sur liste noire')
            .setDescription(`‚úÖ **${user.displayName || user.username}** a √©t√© mis sur liste noire du salon vocal.`)
            .addFields([
                { name: 'üë§ Utilisateur banni', value: `${user.tag} (${user.id})`, inline: true },
                { name: 'üéµ Salon', value: `<#${channel.id}>`, inline: true },
                { name: 'üö´ Effet', value: 'L\'utilisateur ne peut plus acc√©der √† ce salon.', inline: false }
            ])
            .setTimestamp();
            
        await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
        // console.log(`[AUTO-VOICE] üö´ ${user.tag} mis sur liste noire de ${channel.name} par ${interaction.user.tag}`);
        
    } catch (error) {
        console.error('[AUTO-VOICE] Erreur lors du blacklist:', error);
        
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ùå Erreur de liste noire')
            .setDescription('Impossible de mettre cet utilisateur sur liste noire.')
            .addFields([
                { name: 'üîß Causes possibles', value: '‚Ä¢ ID utilisateur invalide\n‚Ä¢ Utilisateur introuvable\n‚Ä¢ Erreur de permissions', inline: false }
            ])
            .setTimestamp();
        
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
    }
}

// Gestionnaire pour le modal de permissions
async function handlePermissionsModal(interaction, channel, channelData) {
    const userInput = interaction.fields.getTextInputValue('permission_user');
    let userId = userInput.replace(/[<@!>]/g, '');
    
    try {
        const user = await interaction.client.users.fetch(userId);
        const autoVoiceData = loadAutoVoiceData();
        const guildId = interaction.guild.id;
        
        // Ajouter aux utilisateurs autoris√©s
        if (!channelData.authorizedUsers) {
            channelData.authorizedUsers = [];
        }
        
        if (!channelData.authorizedUsers.includes(userId)) {
            channelData.authorizedUsers.push(userId);
            
            // Sauvegarder les donn√©es
            const userChannelKey = Object.keys(autoVoiceData[guildId].userChannels).find(
                key => autoVoiceData[guildId].userChannels[key].channelId === channel.id
            );
            if (userChannelKey) {
                autoVoiceData[guildId].userChannels[userChannelKey] = channelData;
                saveAutoVoiceData(autoVoiceData);
            }
        }
        
        // Donner les permissions de gestion
        await channel.permissionOverwrites.edit(userId, {
            ViewChannel: true,
            Connect: true,
            Speak: true,
            ManageChannels: true,
            ManageRoles: true,
            MoveMembers: true,
            MuteMembers: true,
            DeafenMembers: true
        });
        
        const embed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('üîë Permissions accord√©es')
            .setDescription(`‚úÖ **${user.displayName || user.username}** a re√ßu les permissions de gestion pour ce salon vocal.`)
            .addFields([
                { name: 'üë§ Utilisateur autoris√©', value: `${user.tag} (${user.id})`, inline: true },
                { name: 'üéµ Salon', value: `<#${channel.id}>`, inline: true },
                { name: 'üîß Permissions', value: '‚Ä¢ Voir le salon\n‚Ä¢ Se connecter\n‚Ä¢ Parler\n‚Ä¢ G√©rer le salon\n‚Ä¢ D√©placer les membres\n‚Ä¢ Couper le micro', inline: false }
            ])
            .setTimestamp();
            
        await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
        // console.log(`[AUTO-VOICE] üîë ${user.tag} a re√ßu les permissions pour ${channel.name} par ${interaction.user.tag}`);
        
    } catch (error) {
        console.error('[AUTO-VOICE] Erreur lors de l\'attribution des permissions:', error);
        
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ùå Erreur de permissions')
            .setDescription('Impossible d\'accorder les permissions √† cet utilisateur.')
            .addFields([
                { name: 'üîß Causes possibles', value: '‚Ä¢ ID utilisateur invalide\n‚Ä¢ Utilisateur introuvable\n‚Ä¢ Erreur de permissions', inline: false }
            ])
            .setTimestamp();
        
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
    }
}

// Gestionnaire pour le modal d'√©dition
async function handleEditModal(interaction, channel, channelData) {
    const nameInput = interaction.fields.getTextInputValue('channel_name');
    const limitInput = interaction.fields.getTextInputValue('user_limit');
    const bitrateInput = interaction.fields.getTextInputValue('bitrate');
    
    try {
        const updates = {};
        
        if (nameInput && nameInput.trim() !== '') {
            updates.name = nameInput.trim();
        }
        
        if (limitInput && limitInput.trim() !== '') {
            const limit = parseInt(limitInput);
            if (!isNaN(limit) && limit >= 0 && limit <= 99) {
                updates.userLimit = limit;
            }
        }
        
        if (bitrateInput && bitrateInput.trim() !== '') {
            const bitrate = parseInt(bitrateInput);
            if (!isNaN(bitrate) && bitrate >= 8 && bitrate <= 384) {
                updates.bitrate = bitrate * 1000;
            }
        }
        
        if (Object.keys(updates).length > 0) {
            await channel.edit(updates);
            
            const embed = new EmbedBuilder()
                .setColor('#00FF00')
                .setTitle('‚úèÔ∏è Salon modifi√©')
                .setDescription('‚úÖ Le salon vocal a √©t√© mis √† jour avec succ√®s.')
                .addFields([
                    { name: 'üéµ Salon', value: `<#${channel.id}>`, inline: true },
                    { name: 'üìù Modifications', value: Object.keys(updates).map(key => {
                        if (key === 'bitrate') return `‚Ä¢ D√©bit audio: ${updates[key] / 1000}kbps`;
                        if (key === 'userLimit') return `‚Ä¢ Limite d'utilisateurs: ${updates[key] || 'Illimit√©e'}`;
                        if (key === 'name') return `‚Ä¢ Nom: ${updates[key]}`;
                        return `‚Ä¢ ${key}: ${updates[key]}`;
                    }).join('\n'), inline: true }
                ])
                .setTimestamp();
                
            await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
            // console.log(`[AUTO-VOICE] ‚úèÔ∏è Salon ${channel.name} modifi√© par ${interaction.user.tag}`);
        } else {
            const errorEmbed = new EmbedBuilder()
                .setColor('#FFA500')
                .setTitle('‚ö†Ô∏è Aucune modification valide')
                .setDescription('Aucune modification valide n\'a √©t√© fournie.')
                .addFields([
                    { name: 'üí° Conseils', value: '‚Ä¢ Nom: 1-100 caract√®res\n‚Ä¢ Limite: 0-99 utilisateurs\n‚Ä¢ D√©bit: 8-384 kbps', inline: false }
                ])
                .setTimestamp();
            
            await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
        }
        
    } catch (error) {
        console.error('[AUTO-VOICE] Erreur lors de l\'√©dition du salon:', error);
        
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ùå Erreur de modification')
            .setDescription('Impossible de modifier le salon vocal.')
            .addFields([
                { name: 'üîß Causes possibles', value: '‚Ä¢ Permissions insuffisantes\n‚Ä¢ Valeurs invalides\n‚Ä¢ Erreur de connexion', inline: false }
            ])
            .setTimestamp();
        
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
    }
}

// üîí Action: Toggle Privacy
async function handlePrivacyAction(interaction, channel, channelData) {
    try {
        const everyoneRole = interaction.guild.roles.everyone;
        const currentOverwrite = channel.permissionOverwrites.cache.get(everyoneRole.id);
        
        let isCurrentlyPrivate = currentOverwrite && currentOverwrite.deny.has('Connect');
        
        if (isCurrentlyPrivate) {
            // Rendre public
            await channel.permissionOverwrites.edit(everyoneRole, {
                Connect: true,
                ViewChannel: true
            });
            
            const embed = new EmbedBuilder()
                .setColor('#00FF00')
                .setTitle('üåê Salon rendu public')
                .setDescription('‚úÖ Votre salon vocal est maintenant accessible √† tous les membres du serveur.')
                .addFields([
                    { name: 'üéµ Salon', value: `<#${channel.id}>`, inline: true },
                    { name: 'üîì Statut', value: 'Public', inline: true },
                    { name: 'üë• Acc√®s', value: 'Tous les membres', inline: true }
                ])
                .setTimestamp();
                
            await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
        } else {
            // Rendre priv√©
            await channel.permissionOverwrites.edit(everyoneRole, {
                Connect: false,
                ViewChannel: true
            });
            
            const embed = new EmbedBuilder()
                .setColor('#FFA500')
                .setTitle('üîí Salon rendu priv√©')
                .setDescription('‚úÖ Votre salon vocal est maintenant priv√©. Seules les personnes autoris√©es peuvent rejoindre.')
                .addFields([
                    { name: 'üéµ Salon', value: `<#${channel.id}>`, inline: true },
                    { name: 'üîí Statut', value: 'Priv√©', inline: true },
                    { name: 'üë• Acc√®s', value: 'Membres autoris√©s uniquement', inline: true }
                ])
                .setTimestamp();
                
            await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
        }
        
        // console.log(`[AUTO-VOICE] üîí Confidentialit√© du salon ${channel.name} modifi√©e par ${interaction.user.tag} (${isCurrentlyPrivate ? 'Public' : 'Priv√©'})`);
        
    } catch (error) {
        console.error('[AUTO-VOICE] Erreur lors du changement de confidentialit√©:', error);
        
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ùå Erreur de confidentialit√©')
            .setDescription('Impossible de modifier la confidentialit√© du salon.')
            .setTimestamp();
        
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
    }
}

// üîÑ Action: Refresh Panel
async function handleRefreshAction(interaction, channel, channelData) {
    try {
        // Importer la fonction createManagementPanel depuis voiceStateUpdate.js
        const { createManagementPanel } = await import('../events/voiceStateUpdate.js');
        
        // R√©cup√©rer le propri√©taire
        const owner = await interaction.guild.members.fetch(channelData.ownerId);
        
        // Supprimer l'ancien panneau si possible
        try {
            const messages = await channel.messages.fetch({ limit: 50 });
            const botMessages = messages.filter(msg => 
                msg.author.id === interaction.client.user.id && 
                msg.embeds.length > 0 && 
                msg.embeds[0].title?.includes('Panneau de Configuration Vocal')
            );
            
            for (const message of botMessages.values()) {
                await message.delete();
            }
        } catch (deleteError) {
            // console.log('[AUTO-VOICE] Impossible de supprimer l\'ancien panneau:', deleteError.message);
        }
        
        // Cr√©er un nouveau panneau avec les informations mises √† jour
        await createManagementPanel(channel, owner);
        
        const embed = new EmbedBuilder()
            .setColor('#00FF00')
            .setTitle('üîÑ Panneau actualis√©')
            .setDescription('‚úÖ Le panneau de gestion a √©t√© mis √† jour avec les informations en temps r√©el.')
            .addFields([
                { name: 'üéµ Salon', value: `<#${channel.id}>`, inline: true },
                { name: 'üë• Membres', value: `${channel.members.size} connect√©s`, inline: true },
                { name: '‚è∞ Mise √† jour', value: 'Maintenant', inline: true }
            ])
            .setTimestamp();
            
        await interaction.reply({ embeds: [embed], flags: MessageFlags.Ephemeral });
        // console.log(`[AUTO-VOICE] üîÑ Panneau actualis√© pour le salon ${channel.name} par ${interaction.user.tag}`);
        
    } catch (error) {
        console.error('[AUTO-VOICE] Erreur lors de l\'actualisation du panneau:', error);
        
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ùå Erreur d\'actualisation')
            .setDescription('Impossible d\'actualiser le panneau de gestion.')
            .setTimestamp();
        
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
    }
}

// üóëÔ∏è Action: Delete Channel
async function handleDeleteAction(interaction, channel, channelData) {
    try {
        const confirmEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ö†Ô∏è Confirmation de suppression')
            .setDescription('√ätes-vous s√ªr de vouloir supprimer d√©finitivement ce salon vocal ?')
            .addFields([
                { name: 'üéµ Salon √† supprimer', value: `<#${channel.id}>`, inline: true },
                { name: 'üë• Membres connect√©s', value: `${channel.members.size}`, inline: true },
                { name: '‚ö†Ô∏è Attention', value: 'Cette action est irr√©versible !', inline: false }
            ])
            .setTimestamp();
        
        const confirmButton = new ButtonBuilder()
            .setCustomId(`confirm_delete_${channel.id}`)
            .setLabel('Confirmer la suppression')
            .setEmoji('üóëÔ∏è')
            .setStyle(ButtonStyle.Danger);
            
        const cancelButton = new ButtonBuilder()
            .setCustomId(`cancel_delete_${channel.id}`)
            .setLabel('Annuler')
            .setEmoji('‚ùå')
            .setStyle(ButtonStyle.Secondary);
        
        const row = new ActionRowBuilder().addComponents(confirmButton, cancelButton);
        
        await interaction.reply({ embeds: [confirmEmbed], components: [row], flags: MessageFlags.Ephemeral });
        
        // Attendre la confirmation
        const filter = (i) => i.user.id === interaction.user.id && (i.customId.startsWith('confirm_delete_') || i.customId.startsWith('cancel_delete_'));
        const collector = interaction.channel.createMessageComponentCollector({ filter, time: 30000 });
        
        collector.on('collect', async (i) => {
            if (i.customId.startsWith('confirm_delete_')) {
                try {
                    // Supprimer les donn√©es
                    const autoVoiceData = loadAutoVoiceData();
                    const guildId = interaction.guild.id;
                    delete autoVoiceData[guildId].userChannels[channelData.ownerId];
                    saveAutoVoiceData(autoVoiceData);
                    
                    // Supprimer le salon
                    await channel.delete();
                    
                    const successEmbed = new EmbedBuilder()
                        .setColor('#00FF00')
                        .setTitle('‚úÖ **Salon Supprim√© avec Succ√®s**')
                        .setDescription(`
> üóëÔ∏è **Suppression termin√©e**
> Le salon vocal a √©t√© **d√©finitivement supprim√©** du serveur.

\`\`\`yaml
Salon supprim√©: ${channel.name}
Propri√©taire: ${interaction.user.displayName}
Date: ${new Date().toLocaleString('fr-FR')}
\`\`\`

**üîÑ Action suivante :** Vous pouvez cr√©er un nouveau salon en rejoignant un salon "Cr√©er Salon Vocal".
                        `)
                        .setTimestamp();
                    
                    await i.update({ embeds: [successEmbed], components: [] });
                    // console.log(`[AUTO-VOICE] üóëÔ∏è Salon ${channel.name} supprim√© par ${interaction.user.tag}`);
                    
                } catch (error) {
                    console.error('[AUTO-VOICE] Erreur lors de la suppression:', error);
                    
                    const errorEmbed = new EmbedBuilder()
                        .setColor('#FF0000')
                        .setTitle('‚ùå **Erreur de Suppression**')
                        .setDescription(`
> ‚ö†Ô∏è **Probl√®me technique**
> Impossible de supprimer le salon vocal.

\`\`\`yaml
Salon: ${channel.name}
Erreur: Suppression √©chou√©e
Statut: Salon toujours actif
\`\`\`

**üí° Solutions possibles :**
‚Ä¢ V√©rifiez les permissions du bot
‚Ä¢ R√©essayez dans quelques instants
‚Ä¢ Contactez un administrateur si le probl√®me persiste
                        `)
                        .setTimestamp();
                    
                    await i.update({ embeds: [errorEmbed], components: [] });
                }
            } else {
                const cancelEmbed = new EmbedBuilder()
                    .setColor('#FFA500')
                    .setTitle('‚ùå Suppression annul√©e')
                    .setDescription('La suppression du salon a √©t√© annul√©e.')
                    .setTimestamp();
                
                await i.update({ embeds: [cancelEmbed], components: [] });
            }
            collector.stop();
        });
        
        collector.on('end', async (collected) => {
            if (collected.size === 0) {
                const timeoutEmbed = new EmbedBuilder()
                    .setColor('#FFA500')
                    .setTitle('‚è∞ Temps √©coul√©')
                    .setDescription('La demande de suppression a expir√©.')
                    .setTimestamp();
                
                try {
                    await interaction.editReply({ embeds: [timeoutEmbed], components: [] });
                } catch (error) {
                    // console.log('[AUTO-VOICE] Impossible de modifier la r√©ponse expir√©e');
                }
            }
        });
        
    } catch (error) {
        console.error('[AUTO-VOICE] Erreur lors de la demande de suppression:', error);
        
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ùå Erreur')
            .setDescription('Impossible de traiter la demande de suppression.')
            .setTimestamp();
        
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
    }
}

// Gestionnaire pour l'action logs avec temps r√©el
async function handleLogsAction(interaction, channel, channelData) {
    try {
        const logs = loadVoiceActivityLogs();
        const channelLogs = logs[channel.id] || {};
        
        // Fonction pour formater la dur√©e en temps r√©el
        function formatDurationRealTime(milliseconds) {
            if (!milliseconds || milliseconds <= 0) return '0s';
            
            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) return `${days}j ${hours % 24}h ${minutes % 60}m ${seconds % 60}s`;
            if (hours > 0) return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
            if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
            return `${seconds}s`;
        }
        
        // Fonction pour formater la date
        function formatDate(dateString) {
            if (!dateString) return 'Jamais';
            const date = new Date(dateString);
            return `<t:${Math.floor(date.getTime() / 1000)}:R>`;
        }
        
        // Fonction pour cr√©er l'embed avec donn√©es en temps r√©el
        function createLogsEmbed() {
            const currentTime = Date.now();
            
            if (Object.keys(channelLogs).length === 0) {
                return new EmbedBuilder()
                    .setColor('#FFA500')
                    .setTitle('üìä **Logs d\'activit√© vocale - Temps R√©el**')
                    .setDescription(`
> üìã **Aucune activit√© enregistr√©e**
> Ce salon n'a pas encore d'historique d'activit√© vocale.

\`\`\`yaml
Salon: ${channel.name}
Statut: Nouveau salon
Activit√©: Aucune donn√©e
Mise √† jour: ${new Date().toLocaleTimeString('fr-FR')}
\`\`\`

**üí° Info :** Les logs commenceront √† s'enregistrer d√®s que des utilisateurs rejoindront ce salon.
                    `)
                    .setTimestamp();
            }
            
            // Identifier les utilisateurs actuellement connect√©s
            const connectedMembers = channel.members.filter(member => !member.user.bot);
            const connectedUserIds = connectedMembers.map(member => member.id);
            
            // Calculer les sessions en cours
            const activeSessions = [];
            connectedUserIds.forEach(userId => {
                const userData = channelLogs[userId];
                if (userData && userData.sessions && userData.sessions.length > 0) {
                    const lastSession = userData.sessions[userData.sessions.length - 1];
                    if (lastSession.joinTime && !lastSession.leaveTime) {
                        const sessionDuration = currentTime - new Date(lastSession.joinTime).getTime();
                        activeSessions.push({
                            username: userData.username,
                            joinTime: new Date(lastSession.joinTime),
                            currentDuration: sessionDuration,
                            userId: userId
                        });
                    }
                }
            });
            
            // Trier les utilisateurs par nombre de connexions
            const sortedUsers = Object.entries(channelLogs)
                .sort(([,a], [,b]) => b.joinCount - a.joinCount)
                .slice(0, 8); // Top 8 pour laisser place aux sessions actives
            
            // Calculer les statistiques globales
            const totalUsers = Object.keys(channelLogs).length;
            const totalConnections = Object.values(channelLogs).reduce((sum, user) => sum + user.joinCount, 0);
            const totalTimeSpent = Object.values(channelLogs).reduce((sum, user) => sum + (user.totalTimeSpent || 0), 0);
            
            // Ajouter le temps des sessions en cours au total
            const currentSessionTime = activeSessions.reduce((sum, session) => sum + session.currentDuration, 0);
            const totalTimeWithCurrent = totalTimeSpent + currentSessionTime;
            
            // Cr√©er l'embed principal
            const logsEmbed = new EmbedBuilder()
                .setColor('#00FF88')
                .setTitle('üìä **Logs d\'activit√© vocale - Temps R√©el**')
                .setDescription(`
> üéØ **Statistiques du salon**
> Donn√©es mises √† jour en temps r√©el toutes les 10 secondes.

\`\`\`yaml
Salon: ${channel.name}
Utilisateurs uniques: ${totalUsers}
Connexions totales: ${totalConnections}
Temps total pass√©: ${formatDurationRealTime(totalTimeWithCurrent)}
Connect√©s maintenant: ${connectedMembers.size} personne${connectedMembers.size > 1 ? 's' : ''}
Mise √† jour: ${new Date().toLocaleTimeString('fr-FR')}
\`\`\`
                `)
                .setTimestamp();
            
            // Ajouter les sessions actives en temps r√©el
            if (activeSessions.length > 0) {
                const activeSessionsText = activeSessions.map(session => {
                    return `üü¢ **${session.username}**\n` +
                           `   ‚îî Session en cours: ${formatDurationRealTime(session.currentDuration)}\n` +
                           `   ‚îî Connect√© depuis: ${formatDate(session.joinTime.toISOString())}`;
                }).join('\n\n');
                
                logsEmbed.addFields([
                    { 
                        name: 'üî¥ **Sessions actives en temps r√©el**', 
                        value: activeSessionsText.length > 1024 ? activeSessionsText.substring(0, 1021) + '...' : activeSessionsText, 
                        inline: false 
                    }
                ]);
            }
            
            // Ajouter le top des utilisateurs
            if (sortedUsers.length > 0) {
                const topUsersText = sortedUsers.map(([userId, userData], index) => {
                    const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                    const isOnline = connectedUserIds.includes(userId) ? 'üü¢' : '‚ö´';
                    
                    // Calculer le temps total incluant la session en cours si applicable
                    let totalTime = userData.totalTimeSpent || 0;
                    if (connectedUserIds.includes(userId)) {
                        const activeSession = activeSessions.find(s => s.userId === userId);
                        if (activeSession) {
                            totalTime += activeSession.currentDuration;
                        }
                    }
                    
                    return `${medal} ${isOnline} **${userData.username}**\n` +
                           `   ‚îî ${userData.joinCount} connexions ‚Ä¢ ${formatDurationRealTime(totalTime)} total\n` +
                           `   ‚îî Derni√®re visite: ${formatDate(userData.lastJoin)}`;
                }).join('\n\n');
                
                logsEmbed.addFields([
                    { 
                        name: 'üë• **Top utilisateurs les plus actifs**', 
                        value: topUsersText.length > 1024 ? topUsersText.substring(0, 1021) + '...' : topUsersText, 
                        inline: false 
                    }
                ]);
            }
            
            return logsEmbed;
        }
        
        // Boutons pour actualisation automatique et manuelle
        const actionButtons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId(`autovoice_logs_realtime_${channel.id}`)
                    .setLabel('Mode Temps R√©el (10s)')
                    .setEmoji('üî¥')
                    .setStyle(ButtonStyle.Success),
                new ButtonBuilder()
                    .setCustomId(`autovoice_logs_${channel.id}`)
                    .setLabel('Actualiser maintenant')
                    .setEmoji('üîÑ')
                    .setStyle(ButtonStyle.Secondary)
            );
        
        // Envoyer la r√©ponse initiale
        const initialEmbed = createLogsEmbed();
        const response = await interaction.reply({ 
            embeds: [initialEmbed], 
            components: [actionButtons],
            flags: MessageFlags.Ephemeral,
            fetchReply: true
        });
        
        // Syst√®me de mise √† jour automatique toutes les 10 secondes
        let updateCount = 0;
        const maxUpdates = 30; // 5 minutes maximum (30 * 10s)
        
        const updateInterval = setInterval(async () => {
            try {
                updateCount++;
                
                // Arr√™ter apr√®s 5 minutes pour √©viter la surcharge
                if (updateCount >= maxUpdates) {
                    clearInterval(updateInterval);
                    
                    // Message final indiquant l'arr√™t de la mise √† jour
                    const finalEmbed = createLogsEmbed()
                        .setColor('#FF6B6B')
                        .setFooter({ text: '‚è∞ Mise √† jour automatique arr√™t√©e apr√®s 5 minutes. Cliquez sur "Actualiser" pour continuer.' });
                    
                    const finalButtons = new ActionRowBuilder()
                        .addComponents(
                            new ButtonBuilder()
                                .setCustomId(`autovoice_logs_${channel.id}`)
                                .setLabel('Actualiser les logs')
                                .setEmoji('üîÑ')
                                .setStyle(ButtonStyle.Primary)
                        );
                    
                    await response.edit({ 
                        embeds: [finalEmbed], 
                        components: [finalButtons] 
                    });
                    return;
                }
                
                // Recharger les logs pour avoir les donn√©es les plus r√©centes
                const updatedLogs = loadVoiceActivityLogs();
                Object.assign(channelLogs, updatedLogs[channel.id] || {});
                
                // Cr√©er l'embed mis √† jour
                const updatedEmbed = createLogsEmbed();
                
                // Mettre √† jour le message
                await response.edit({ 
                    embeds: [updatedEmbed], 
                    components: [actionButtons] 
                });
                
            } catch (error) {
                console.error('[VOICE-LOGS] ‚ùå Erreur lors de la mise √† jour automatique:', error);
                clearInterval(updateInterval);
            }
        }, 10000); // Mise √† jour toutes les 10 secondes
        
        // console.log(`[VOICE-LOGS] ‚úÖ Logs temps r√©el d√©marr√©s pour ${interaction.user.displayName} - Canal: ${channel.name}`);
        
    } catch (error) {
        console.error('[VOICE-LOGS] ‚ùå Erreur lors de l\'affichage des logs:', error);
        
        const errorEmbed = new EmbedBuilder()
            .setColor('#FF0000')
            .setTitle('‚ùå **Erreur lors du chargement des logs**')
            .setDescription(`
> üîß **Probl√®me technique**
> Impossible de charger les logs d'activit√© vocale.

\`\`\`yaml
Erreur: ${error.message}
Canal: ${channel.name}
Action: Chargement des logs temps r√©el
\`\`\`

**üí° Solution :** R√©essayez dans quelques instants ou contactez un administrateur.
            `)
            .setTimestamp();
        
        await interaction.reply({ embeds: [errorEmbed], flags: MessageFlags.Ephemeral });
    }
}

export {
    handleManagementButtons,
    handleSelectMenuInteraction,
    handleModalSubmit,
    handleLogsAction,
    loadAutoVoiceData,
    saveAutoVoiceData
};