import { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, Colors } from 'discord.js';
import { createErrorEmbed, Emojis } from '../../../src/utils/embeds.js';
import messageXPHandler from '../../../src/utils/messageXpHandler.js';
import voiceXPHandler from '../../../src/utils/voiceXpHandler.js';
import XPCalculator from '../../../src/utils/xpCalculator.js';

export default {
  name: 'userinfo',
  description: 'Affiche les informations d√©taill√©es d\'un utilisateur',
  category: 'utilisateur',
  usage: 'userinfo [@utilisateur]',
  async execute(message, args, client) {
    try {
      // R√©cup√©rer l'utilisateur mentionn√© ou l'auteur du message
      let targetUser = message.author;
      if (args.length > 0) {
        // Essayer de r√©cup√©rer l'utilisateur mentionn√©
        const mention = args[0];
        if (mention.startsWith('<@') && mention.endsWith('>')) {
          const userId = mention.slice(2, -1).replace('!', '');
          targetUser = await client.users.fetch(userId).catch(() => null);
        } else {
          // Essayer de r√©cup√©rer par ID
          targetUser = await client.users.fetch(args[0]).catch(() => null);
        }
      }

      if (!targetUser) {
        return message.reply({ embeds: [createErrorEmbed('Utilisateur introuvable', 'Impossible de trouver cet utilisateur.')] });
      }

      const member = await message.guild.members.fetch(targetUser.id).catch(() => null);
      
      if (!member) {
        return message.reply({ 
          embeds: [createErrorEmbed('Utilisateur introuvable', 'Cet utilisateur n\'est pas membre de ce serveur.')] 
        });
      }

      console.log(`‚ÑπÔ∏è  [INFO] Commande !userinfo utilis√©e par ${message.author.tag} pour ${targetUser.tag}`);

      // Cr√©er l'embed de la page "Personne" par d√©faut
      const embed = await createUserInfoEmbed(member, 'person', message.author.id);
      const components = createUserInfoButtons('person', targetUser.id);

      await message.reply({ 
        embeds: [embed], 
        components: components
      });
    } catch (error) {
      console.error('‚ùå [ERREUR] Pr√©fixe userinfo:', error);
      return message.reply({ embeds: [createErrorEmbed('Erreur', 'Une erreur est survenue lors de l\'affichage des informations utilisateur.')] });
    }
  },
};

// Fonction pour cr√©er l'embed selon la page
async function createUserInfoEmbed(member, page, viewerId = null) {
  const user = member.user;
  const guild = member.guild;
  
  // Couleur bas√©e sur le r√¥le le plus haut ou bleu par d√©faut
  const highestRole = member.roles.highest;
  const embedColor = highestRole.color !== 0 ? highestRole.color : Colors.Blurple;

  switch (page) {
    case 'person': // Page Informations utilisateur
      return await createUserInfoPage(member, embedColor);
    case 'xp': // Page XP
      return await createXPPage(member, embedColor);
    case 'social': // Page R√©seaux sociaux
      return createSocialPage(member, embedColor, viewerId);
    default:
      return await createUserInfoPage(member, embedColor);
  }
}

// Page 1: Informations utilisateur
async function createUserInfoPage(member, color) {
  const user = member.user;
  
  // Calcul du temps √©coul√© depuis la cr√©ation du compte
  const accountAge = getTimeAgo(user.createdAt);
  const joinAge = getTimeAgo(member.joinedAt);
  
  // Status et activit√©
  const presence = member.presence;
  const status = getStatusText(presence?.status);
  const activity = getActivityText(presence?.activities);
  
  // Nombre de r√¥les (sans @everyone)
  const roleCount = member.roles.cache.size - 1;
  
  // Permissions sp√©ciales
  const isAdmin = member.permissions.has('Administrator');
  const isModerator = member.permissions.has('ManageMessages') || member.permissions.has('KickMembers');
  
  const embed = new EmbedBuilder()
        .setColor(color)
        .setTitle(`${Emojis.profile} **Profil de ${user.username}**`)
        .setThumbnail(user.displayAvatarURL({ dynamic: true, size: 256 }))
        .setDescription(`${Emojis.clipboard} **Informations g√©n√©rales**\n\`\`\`yaml\nPseudo    : "${user.tag}"\nID        : ${user.id}\nType      : ${user.bot ? 'Bot' : 'Utilisateur'}\nStatut    : ${getStatusText(presence?.status)}\`\`\``)
         .addFields(
             { 
                 name: `${Emojis.calendar} **Dates importantes**`, 
                 value: `\`\`\`diff\n+ ${Emojis.birthday} Compte cr√©√©\n  ${accountAge}\n\n+ ${Emojis.join} Rejoint le serveur\n  ${joinAge}\`\`\``, 
                 inline: false 
             },
             { 
                 name: `${Emojis.roles} **R√¥les & Permissions**`, 
                 value: `**${Emojis.progress} R√¥les :** \`${roleCount} r√¥le${roleCount > 1 ? 's' : ''}\`\n\n**${Emojis.permissions} Niveau :**\n${isAdmin ? `${Emojis.crown} \`ADMINISTRATEUR\`` : isModerator ? `${Emojis.moderator} \`MOD√âRATEUR\`` : `${Emojis.member} \`MEMBRE\``}`, 
                 inline: true 
             },
             { 
                 name: `${Emojis.phone} **Statut & Activit√©**`, 
                 value: `**${Emojis.status} Pr√©sence :**\n\`${getStatusText(presence?.status)}\`\n\n**${Emojis.activity} Activit√© :**\n${activity === 'Aucune activit√©' ? `\`${activity}\`` : `**${activity}**`}`, 
                 inline: true 
             }
         );

    embed.setFooter({ text: `${Emojis.search} Informations d√©taill√©es ‚Ä¢ Page Personne ‚Ä¢ ${new Date().toLocaleString('fr-FR')}` })
        .setTimestamp();

    return embed;
}

// Page 2: XP et Statistiques
async function createXPPage(member, color) {
  const user = member.user;
  
  // R√©cup√©ration des donn√©es XP
  let xpInfo = null;
  let errorMessage = null;
  
  try {
    const messageStats = await messageXPHandler.getStats(user.id);
    const voiceStats = await voiceXPHandler.getStats(user.id);
    
    const messageXP = messageStats ? messageStats.xp : 0;
    const voiceXP = voiceStats ? voiceStats.xp : 0;
    const totalXP = messageXP + voiceXP;
    
    const level = XPCalculator.calculateLevel(totalXP);
    const xpForCurrentLevel = XPCalculator.calculateXPForLevel(level);
    const xpForNextLevel = XPCalculator.calculateXPForLevel(level + 1);
    const progressXP = totalXP - xpForCurrentLevel;
    const neededXP = xpForNextLevel - xpForCurrentLevel;
    const progressPercentage = Math.round((progressXP / neededXP) * 100);
    
    xpInfo = {
      level,
      messageXP,
      voiceXP,
      totalXP,
      progressXP,
      neededXP,
      progressPercentage,
      xpForCurrentLevel,
      xpForNextLevel
    };
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des donn√©es XP:', error);
    errorMessage = 'Impossible de r√©cup√©rer les donn√©es XP';
  }
  
  const embed = new EmbedBuilder()
    .setColor(color)
    .setTitle(`${Emojis.star} **Statistiques XP de ${user.username}**`)
    .setThumbnail(user.displayAvatarURL({ dynamic: true, size: 256 }));
  
  if (xpInfo) {
    const progressBar = createProgressBar(xpInfo.progressPercentage);
    
    embed.setDescription(`${Emojis.level} **Niveau actuel :** \`${xpInfo.level}\`\n${Emojis.progress} **Progression :** \`${xpInfo.progressXP}/${xpInfo.neededXP} XP\` (${xpInfo.progressPercentage}%)\n\n${progressBar}`)
      .addFields(
        {
          name: `${Emojis.message} **XP Messages**`,
          value: `\`\`\`yaml\nTotal: ${xpInfo.messageXP.toLocaleString()} XP\nSource: Messages envoy√©s\`\`\``,
          inline: true
        },
        {
          name: `${Emojis.voice} **XP Vocal**`,
          value: `\`\`\`yaml\nTotal: ${xpInfo.voiceXP.toLocaleString()} XP\nSource: Temps en vocal\`\`\``,
          inline: true
        },
        {
          name: `${Emojis.total} **XP Total**`,
          value: `\`\`\`yaml\nTotal: ${xpInfo.totalXP.toLocaleString()} XP\nCombin√©s: Messages + Vocal\`\`\``,
          inline: true
        },
        {
          name: `${Emojis.level} **Informations de Niveau**`,
          value: `**Niveau actuel :** \`${xpInfo.level}\`\n**XP pour ce niveau :** \`${xpInfo.xpForCurrentLevel.toLocaleString()}\`\n**XP pour niveau suivant :** \`${xpInfo.xpForNextLevel.toLocaleString()}\`\n**XP restant :** \`${(xpInfo.xpForNextLevel - xpInfo.totalXP).toLocaleString()}\``,
          inline: false
        }
      );
  } else {
    embed.setDescription(`${Emojis.error} **Erreur**\n${errorMessage || 'Aucune donn√©e XP disponible pour cet utilisateur.'}`);
  }
  
  embed.setFooter({ text: `${Emojis.star} Statistiques XP ‚Ä¢ Page XP ‚Ä¢ ${new Date().toLocaleString('fr-FR')}` })
    .setTimestamp();
  
  return embed;
}

// Page 3: R√©seaux sociaux
function createSocialPage(member, color, viewerId = null) {
  const user = member.user;
  const fs = require('fs');
  const path = require('path');
  
  // Lire les donn√©es des r√©seaux sociaux
  const socialsPath = path.join(__dirname, '../../../json/socials.json');
  let socialsData = {};
  
  try {
    if (fs.existsSync(socialsPath)) {
      const data = fs.readFileSync(socialsPath, 'utf8');
      socialsData = JSON.parse(data);
    }
  } catch (error) {
    console.error('‚ùå [SOCIAL] Erreur lecture socials.json:', error);
  }
  
  const userSocials = socialsData[user.id] || {};
  const isOwnProfile = viewerId === user.id;
  
  // Configuration des r√©seaux support√©s
  const supportedNetworks = {
    twitter: { emoji: 'üê¶', name: 'Twitter' },
    instagram: { emoji: 'üì∏', name: 'Instagram' },
    twitch: { emoji: 'üéÆ', name: 'Twitch' },
    github: { emoji: 'üêô', name: 'GitHub' },
    linkedin: { emoji: 'üíº', name: 'LinkedIn' },
    tiktok: { emoji: 'üéµ', name: 'TikTok' }
  };
  
  const embed = new EmbedBuilder()
    .setColor(color)
    .setTitle(`${Emojis.social} **R√©seaux sociaux de ${user.username}**`)
    .setThumbnail(user.displayAvatarURL({ dynamic: true, size: 256 }));
  
  // Filtrer les r√©seaux selon la confidentialit√©
  const visibleNetworks = Object.entries(userSocials).filter(([network, data]) => {
    return isOwnProfile || data.privacy === 'public';
  });
  
  if (visibleNetworks.length === 0) {
    embed.setDescription(`${Emojis.warning} **Aucun r√©seau social configur√©**\n\n` +
      `${isOwnProfile ? 'Vous n\'avez' : 'Cet utilisateur n\'a'} configur√© aucun r√©seau social ${isOwnProfile ? '' : 'public'}.`);
  } else {
    // Cr√©er les champs pour chaque r√©seau
    for (const [networkKey, networkConfig] of Object.entries(supportedNetworks)) {
      const socialData = userSocials[networkKey];
      
      if (socialData && (isOwnProfile || socialData.privacy === 'public')) {
        const privacyIcon = socialData.privacy === 'private' ? 'üîí' : 'üåê';
        const linkText = socialData.link !== 'non d√©fini' ? `[Voir le profil](${socialData.link})` : 'Aucun lien';
        
        embed.addFields({
          name: `${networkConfig.emoji} **${networkConfig.name}**`,
          value: `**Pseudo :** \`${socialData.username}\`\n**Lien :** ${linkText}\n**Confidentialit√© :** ${privacyIcon} ${socialData.privacy === 'private' ? 'Priv√©' : 'Public'}`,
          inline: true
        });
      } else if (isOwnProfile) {
        embed.addFields({
          name: `${networkConfig.emoji} **${networkConfig.name}**`,
          value: `${Emojis.cross} Non configur√©`,
          inline: true
        });
      }
    }
  }
  
  // Section de configuration
  if (isOwnProfile) {
    embed.addFields({
      name: `${Emojis.settings} **Configuration**`,
      value: `Utilisez \`/social add\` pour ajouter un r√©seau\nUtilisez \`/social remove\` pour supprimer\nUtilisez \`/social list\` pour voir tous vos r√©seaux`,
      inline: false
    });
  }
  
  embed.setFooter({ text: `${Emojis.search} Informations d√©taill√©es ‚Ä¢ Page R√©seaux sociaux ‚Ä¢ ${new Date().toLocaleString('fr-FR')}` })
    .setTimestamp();

  return embed;
}

// Fonction pour cr√©er les boutons de navigation
function createUserInfoButtons(currentPage, userId) {
  const personButton = new ButtonBuilder()
    .setCustomId(`userinfo_person_${userId}`)
    .setLabel('üë§ Personne')
    .setStyle(currentPage === 'person' ? ButtonStyle.Primary : ButtonStyle.Secondary);

  const xpButton = new ButtonBuilder()
    .setCustomId(`userinfo_xp_${userId}`)
    .setLabel('‚≠ê XP')
    .setStyle(currentPage === 'xp' ? ButtonStyle.Primary : ButtonStyle.Secondary);

  const socialButton = new ButtonBuilder()
    .setCustomId(`userinfo_social_${userId}`)
    .setLabel('üåê R√©seaux sociaux')
    .setStyle(currentPage === 'social' ? ButtonStyle.Primary : ButtonStyle.Secondary);

  return [new ActionRowBuilder().addComponents(personButton, xpButton, socialButton)];
}

// Fonction pour cr√©er une barre de progression
function createProgressBar(percentage, length = 10) {
  const filled = Math.round((percentage / 100) * length);
  const empty = length - filled;
  return '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
}

// Fonctions utilitaires
function getTimeAgo(date) {
  // Formatage de la date compl√®te avec l'heure
  const options = {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    timeZone: 'Europe/Paris'
  };
  const fullDate = date.toLocaleDateString('fr-FR', options);
  
  // Calcul du temps relatif
  const now = new Date();
  const diffMs = now - date;
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
  const diffMonths = Math.floor(diffDays / 30);
  const diffYears = Math.floor(diffDays / 365);

  let relativeTime;
  if (diffYears > 0) {
    const remainingMonths = Math.floor((diffDays % 365) / 30);
    relativeTime = `il y a ${diffYears} an${diffYears > 1 ? 's' : ''}${remainingMonths > 0 ? ` et ${remainingMonths} mois` : ''}`;
  } else if (diffMonths > 0) {
    const remainingDays = diffDays % 30;
    relativeTime = `il y a ${diffMonths} mois${remainingDays > 0 ? ` et ${remainingDays} jour${remainingDays > 1 ? 's' : ''}` : ''}`;
  } else if (diffDays > 0) {
    relativeTime = `il y a ${diffDays} jour${diffDays > 1 ? 's' : ''}`;
  } else {
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    relativeTime = `il y a ${diffHours} heure${diffHours > 1 ? 's' : ''}`;
  }
  
  // Retourner la date compl√®te avec le temps relatif
  return `${fullDate}\n(${relativeTime})`;
}

function getStatusText(status) {
  switch (status) {
    case 'online': return 'üü¢ En ligne';
    case 'idle': return 'üåô Inactif';
    case 'dnd': return '‚õî Ne pas d√©ranger';
    case 'offline':
    default: return '‚ö´ Hors ligne';
  }
}

function getActivityText(activities) {
  if (!activities || activities.length === 0) {
    return 'Aucune activit√©';
  }

  const activity = activities[0];
  switch (activity.type) {
    case 0: return `üéÆ Joue √† ${activity.name}`;
    case 1: return `üì∫ Regarde ${activity.name}`;
    case 2: return `üéµ √âcoute ${activity.name}`;
    case 3: return `üì∫ Stream ${activity.name}`;
    case 5: return `üèÜ En comp√©tition sur ${activity.name}`;
    default: return activity.name || 'Activit√© inconnue';
  }
}



